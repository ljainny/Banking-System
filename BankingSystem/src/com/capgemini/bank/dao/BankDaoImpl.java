package com.capgemini.bank.dao;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.sql.Connection;
import java.sql.Date;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.time.LocalDate;
import java.time.Period;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

import org.apache.log4j.Logger;
import org.apache.log4j.PropertyConfigurator;

import com.capgemini.bank.bean.Account;
import com.capgemini.bank.bean.Customer;
import com.capgemini.bank.bean.FundTransfer;
import com.capgemini.bank.bean.ServiceTracker;
import com.capgemini.bank.bean.Transactions;
import com.capgemini.bank.bean.User;
import com.capgemini.bank.exception.BankException;
import com.capgemini.bank.util.DBUtil;

public class BankDaoImpl implements IBankDao {
	private Logger myLogger = null;
	private Connection connection = null;
	private PreparedStatement pst = null;
	private Statement st = null;
	private ResultSet rs = null;
	private static int count = 0;

	public BankDaoImpl() throws BankException {
		// obtain the connection
		connection = DBUtil.getConnection();
		PropertyConfigurator.configure("resources/log4j.properties");
		myLogger = Logger.getLogger("BankDaoImpl.class");
	}// end of constructor

	public int getUniqueId() throws BankException {
		String sql = "select accNo_seq.currval from dual";
		int accNum = 0;
		try {
			st = connection.createStatement();
			rs = st.executeQuery(sql);
			if (rs.next()) {
				accNum = rs.getInt(1);
				myLogger.info("Autogenerated account Id " + accNum);
			} else
				myLogger.error("Sorry no account Id generated!");
		} catch (SQLException e) {
			myLogger.error("Sorry no account Id generated!" + e.getMessage());
			throw new BankException(e.getMessage());
		} finally {
			try {
				if (st != null)
					st.close();
			} catch (SQLException e) {
				myLogger.error("Sorry no account Id generated!"
						+ e.getMessage());
				throw new BankException(e.getMessage());
			}
		}
		return accNum;
	}// end of method

	public int getUniqueFundTransferId() throws BankException {
		String sql = "select fund_seq.currval from dual";
		int fundTransferId = 0;
		try {
			st = connection.createStatement();
			rs = st.executeQuery(sql);
			if (rs.next()) {
				fundTransferId = rs.getInt(1);
				myLogger.info("Autogenerated CustomerBean Id " + fundTransferId);
			} else
				myLogger.error("Sorry no CustomerBean Id generated!");
		} catch (SQLException e) {
			myLogger.error("Sorry no CustomerBean Id generated!"
					+ e.getMessage());
			throw new BankException(e.getMessage());
		} finally {
			try {
				if (st != null)
					st.close();
			} catch (SQLException e) {
				myLogger.error("Sorry no CustomerBean Id generated!"
						+ e.getMessage());
				throw new BankException(e.getMessage());
			}
		}
		return fundTransferId;
	}

	public int getUniqueTransactionId() throws BankException {
		String sql = "select trans_seq.currval from dual";
		int transactionId = 0;
		try {
			st = connection.createStatement();
			rs = st.executeQuery(sql);
			if (rs.next()) {
				transactionId = rs.getInt(1);
				myLogger.info("Autogenerated CustomerBean Id " + transactionId);
			} else
				myLogger.error("Sorry no CustomerBean Id generated!");
		} catch (SQLException e) {
			myLogger.error("Sorry no CustomerBean Id generated!"
					+ e.getMessage());
			throw new BankException(e.getMessage());
		} finally {
			try {
				if (st != null)
					st.close();
			} catch (SQLException e) {
				myLogger.error("Sorry no CustomerBean Id generated!"
						+ e.getMessage());
				throw new BankException(e.getMessage());
			}
		}
		return transactionId;
	}

	public int getUniqueServiceId() throws BankException {
		String sql = "select service_seq.currval from dual";
		int serviceId = 0;
		try {
			st = connection.createStatement();
			rs = st.executeQuery(sql);
			if (rs.next()) {
				serviceId = rs.getInt(1);
				myLogger.info("Autogenerated CustomerBean Id " + serviceId);
			} else
				myLogger.error("Sorry no CustomerBean Id generated!");
		} catch (SQLException e) {
			myLogger.error("Sorry no CustomerBean Id generated!"
					+ e.getMessage());
			throw new BankException(e.getMessage());
		} finally {
			try {
				if (st != null)
					st.close();
			} catch (SQLException e) {
				myLogger.error("Sorry no CustomerBean Id generated!"
						+ e.getMessage());
				throw new BankException(e.getMessage());
			}
		}
		return serviceId;
	}

	@Override
	public int applyService(ServiceTracker serviceTracker) throws BankException {
		// constructor to initialize logger and get the connection
		int serviceId = 0;
		String sql = "INSERT INTO servicetracker VALUES(service_seq.nextval,?,?,?,?)";
		try {
			connection.setAutoCommit(false);
			pst = connection.prepareStatement(sql);
			// setting the placeholder values

			pst.setString(1, serviceTracker.getServiceDescription());
			pst.setLong(2, serviceTracker.getAccountId());
			Date serviceDate = Date.valueOf(LocalDate.now());
			pst.setDate(3, serviceDate);
			pst.setString(4, serviceTracker.getServiceStatus());
			// now after setting the place holders executeUpdate
			pst.executeUpdate();
			serviceId = getUniqueServiceId();
			// servicetracker.setCustomerId(serviceId);// setting the
			// autogenrated
			// // CustomerBean Id
			myLogger.info("CustomerBean Info added to database : "
					+ serviceTracker);
			connection.commit();
		} catch (SQLException e) {
			myLogger.error("Sorry Unable to add CustomerBean record!!"
					+ e.getMessage());
			try {
				connection.rollback();
			} catch (SQLException e1) {
				throw new BankException(e1.getMessage());
			}
			throw new BankException(e.getMessage());
		} finally {
			try {
				if (pst != null)
					pst.close();
			} catch (SQLException e) {
				myLogger.error("Sorry Unable to add CustomerBean record!!"
						+ e.getMessage());
				throw new BankException(e.getMessage());
			}
		}
		return serviceId;
	}

	@Override
	public String getServiceStatus(int serviceId, int accountId)
			throws BankException {
		String status = "open";
		LocalDate localDate = null;
		LocalDate date = null;
		// String ldate = null;
		int days = 0;
		try {
			String sql = "select service_status,service_raised_date from servicetracker where service_id="
					+ serviceId + " and account_id=" + accountId;
			String sql1 = "select service_id,account_id from servicetracker";
			int service = 0;
			int account = 0;
			pst = connection.prepareStatement(sql1);
			rs = pst.executeQuery();

			while (rs.next()) {
				service = rs.getInt("service_id");
				account = rs.getInt("account_id");
				if (service != serviceId || account != accountId) {
					status = "invalid";
				} else {

					st = connection.createStatement();
					rs = st.executeQuery(sql);

					while (rs.next()) {
						status = rs.getString("service_status");
						localDate = rs.getDate("service_raised_date")
								.toLocalDate();
						date = LocalDate.now();
						Period period = Period.between(localDate, date);
						days = period.getDays();
						System.out.println(days);
						if (days >= 1 && days < 3) {
							sql = "update servicetracker set service_status=? where service_id="
									+ serviceId;
							pst = connection.prepareStatement(sql);
							pst.setString(1, "issued");
							status = "issued";
							pst.executeUpdate();
						} else if (days >= 3 && days < 8) {
							sql = "update servicetracker set service_status=? where service_id="
									+ serviceId;
							pst = connection.prepareStatement(sql);
							pst.setString(1, "dispatched");
							status = "dispatched";
							pst.executeUpdate();
						} else if (days >= 8 && days < 12) {
							sql = "update servicetracker set service_status=? where service_id="
									+ serviceId;
							pst = connection.prepareStatement(sql);
							pst.setString(1, "delivered");
							status = "delivered";
							pst.executeUpdate();
						} else if (days > 12) {
							sql = "update servicetracker set service_status=? where service_id="
									+ serviceId;
							pst = connection.prepareStatement(sql);
							pst.setString(1, "returned");
							status = "returned";
							pst.executeUpdate();
						} else {
							status = "open";
						}

						// System.out.println("Days Elapsed : " + days);
						// ldate = localDate.toString();
					}
				}
			}
		} catch (SQLException e) {
			myLogger.error("Sorry no CustomerBean records found!!"
					+ e.getMessage());
			throw new BankException(e.getMessage());
		} finally {
			try {
				if (st != null)
					st.close();
			} catch (SQLException e) {
				myLogger.error("Sorry no CustomerBean records found!!"
						+ e.getMessage());
				throw new BankException(e.getMessage());
			}
		}
		return status;
	}

	@Override
	public int addDetails(Account account, Customer customer, User user)
			throws BankException {
		int accountId = 0;
		@SuppressWarnings("unused")
		int result = 0;
		String pancard = null;
		String sql = "insert into account_master values(accNo_seq.NEXTVAL,?,?,?)";
		String sql1 = "insert into customer values(?,?,?,?,?)";
		String sql2 = "insert into user_table values(?,?,?,?)";
		String sql3 = "select pancard from customer";
		try {

			connection.setAutoCommit(false);
			st = connection.createStatement();
			rs = st.executeQuery(sql3);

			while (rs.next()) {
				pancard = rs.getString("pancard");

				if (pancard.equals(customer.getPancard())) {
					return 0;
				}
			}
			pst = connection.prepareStatement(sql);

			pst.setString(1, account.getAccountType());
			pst.setDouble(2, account.getAccountBalance());

			LocalDate local = account.getOpenDate();
			Date sqlDate = Date.valueOf(local);
			pst.setDate(3, sqlDate);

			result = pst.executeUpdate();

			accountId = getUniqueId();// invoking method to get custId

			account.setAccountId(accountId);// setting the autogenrated

			pst = connection.prepareStatement(sql1);

			pst.setInt(1, accountId);
			pst.setString(2, customer.getCustomerName());
			pst.setString(3, customer.getEmail());
			pst.setString(4, customer.getAddress());
			pst.setString(5, customer.getPancard());

			result = pst.executeUpdate();
			pst = connection.prepareStatement(sql2);
			pst.setInt(1, accountId);
			pst.setString(2, user.getLoginPassword());
			pst.setString(3, user.getSecretQuestion());
			pst.setString(4, user.getLockStatus());

			result = pst.executeUpdate();
			myLogger.info("User Info added to database : " + account);
			connection.commit();
		} catch (SQLException e) {
			myLogger.error("Sorry Unable to add CustomerBean record!!"
					+ e.getMessage());
			try {
				connection.rollback();
			} catch (SQLException e1) {
				throw new BankException(e1.getMessage());
			}
			throw new BankException(e.getMessage());
		} finally {
			try {
				if (pst != null)
					pst.close();
			} catch (SQLException e) {
				myLogger.error("Sorry Unable to add CustomerBean record!!"
						+ e.getMessage());
				throw new BankException(e.getMessage());
			}
		}

		return accountId;

	}

	@Override
	public int transferFund(FundTransfer fundTransfer, Transactions transactions)
			throws BankException {
		@SuppressWarnings("unused")
		int result = 0;
		int transactionId = 0;
		int fundTransferId = 0;

		String sql = "select account_balance from account_master where account_id="
				+ fundTransfer.getPayeeAccountId();
		// String sql5 = "select account_id from account_master";
		String sql1 = "insert into fund_transfer values(fund_seq.nextval,?,?,?,?)";

		String sql3 = "update account_master set account_balance=(account_balance + ?) where account_id=?";
		String sql4 = "update account_master set account_balance=(account_balance - ?) where account_id=?";

		try {
			st = connection.createStatement();
			rs = st.executeQuery(sql);
			while (rs.next()) {
				int balance = rs.getInt("account_balance");

				if (balance > fundTransfer.getTransferAmount()) {
					pst = connection.prepareStatement(sql1);

					pst.setInt(1, fundTransfer.getAccountId());
					pst.setInt(2, fundTransfer.getPayeeAccountId());
					pst.setDate(3, Date.valueOf(LocalDate.now()));
					pst.setInt(4, fundTransfer.getTransferAmount());

					result = pst.executeUpdate();

					fundTransferId = getUniqueFundTransferId();
					fundTransfer.setFundTransferId(fundTransferId);

					pst = connection.prepareStatement(sql3);

					pst.setInt(1, fundTransfer.getTransferAmount());
					pst.setInt(2, fundTransfer.getPayeeAccountId());
					pst.executeUpdate();

					pst = connection.prepareStatement(sql4);

					pst.setInt(1, fundTransfer.getTransferAmount());
					pst.setInt(2, fundTransfer.getAccountId());
					pst.executeUpdate();

					transactionId = insertTransaction(fundTransfer,
							transactions);
				} else {
					return 2;
				}

			}
		} catch (SQLException e) {
			myLogger.error("Sorry Unable to add CustomerBean record!!"
					+ e.getMessage());
		} finally {
			try {
				if (pst != null)
					pst.close();
			} catch (SQLException e) {
				myLogger.error("Sorry Unable to add CustomerBean record!!"
						+ e.getMessage());
				throw new BankException(e.getMessage());
			}
		}

		return transactionId;
	}

	private int insertTransaction(FundTransfer fundTransfer,
			Transactions transactions) throws BankException {
		@SuppressWarnings("unused")
		int result = 0;
		String sql2 = "insert into transactions values(trans_seq.nextval,?,?,?,?,?,?,?)";
		String sql7 = "select account_balance from account_master where account_id="
				+ fundTransfer.getAccountId();
		String sql5 = "insert into transactions values(?,?,?,?,?,?,?,?)";
		String sql6 = "select account_balance from account_master where account_id="
				+ fundTransfer.getPayeeAccountId();

		int balance = 0;
		int transactionId = 0;

		int currBalance = 0;

		try {
			st = connection.createStatement();
			rs = st.executeQuery(sql7);
			while (rs.next()) {
				balance = rs.getInt("account_balance");
			}

			pst = connection.prepareStatement(sql2);

			pst.setString(1, transactions.getTranDescription());
			pst.setDate(2, Date.valueOf(LocalDate.now()));
			pst.setString(3, transactions.getTransactionType());
			pst.setInt(4, fundTransfer.getTransferAmount());
			pst.setInt(5, fundTransfer.getAccountId());
			pst.setInt(6, fundTransfer.getPayeeAccountId());
			pst.setInt(7, balance);
			result = pst.executeUpdate();
			transactionId = getUniqueTransactionId();
			transactions.setTransactionId(transactionId);

		} catch (SQLException e1) {

			e1.printStackTrace();
		}

		try {
			st = connection.createStatement();

			rs = st.executeQuery(sql6);
			while (rs.next()) {
				currBalance = rs.getInt("account_balance");
			}
			pst = connection.prepareStatement(sql5);
			pst.setInt(1, getUniqueTransactionId());

			pst.setString(2, transactions.getTranDescription());
			pst.setDate(3, Date.valueOf(LocalDate.now()));
			pst.setString(4, transactions.getTransactionType());
			pst.setInt(5, fundTransfer.getTransferAmount());
			pst.setInt(6, fundTransfer.getPayeeAccountId());
			pst.setInt(7, fundTransfer.getAccountId());
			pst.setInt(8, currBalance);
			result = pst.executeUpdate();

		} catch (SQLException e) {

			e.printStackTrace();
		}
		return transactionId;

	}

	@Override
	public List<Transactions> showMiniStatement(int accountId)
			throws BankException {
		String sql = "select * from (select * from transactions "
				+ "where account_id=" + accountId
				+ "order by rownum desc) where rownum<=10";
		List<Transactions> transactionDetails = null;
		Transactions transaction = null;
		try {

			pst = connection.prepareStatement(sql);
			rs = pst.executeQuery(sql);
			transactionDetails = new ArrayList<Transactions>();

			while (rs.next()) {
				transaction = new Transactions();

				transaction.setTransactionId(rs.getInt("transaction_id"));
				transaction
						.setTranDescription(rs.getString("tran_description"));
				transaction.setDateOfTransaction((rs
						.getDate("dateoftransaction").toLocalDate()));
				transaction.setTransactionType(rs.getString("transactiontype"));
				transaction.setTranAmount(rs.getInt("tranAmount"));
				transaction.setAccountId(rs.getInt("account_id"));
				transaction.setPayeeAccountId(rs.getInt("payee_account_id"));
				transaction.setBalance(rs.getInt("balance"));
				transactionDetails.add(transaction);

				String pathname = "src/MiniStatement " + accountId + " "
						+ LocalDate.now() + ".txt";
				File file = new File(pathname);

				if (!file.exists()) {
					file.createNewFile();
				} else {
					Iterator<Transactions> iterator = transactionDetails
							.iterator();
					FileOutputStream out = new FileOutputStream(file);
					ObjectOutputStream objOut = new ObjectOutputStream(out);

					while (iterator.hasNext()) {
						Transactions tran = iterator.next();
						objOut.writeObject(tran.getTransactionId() + "\t"
								+ tran.getTranDescription() + "\t"
								+ tran.getDateOfTransaction() + "\t"
								+ tran.getTransactionType() + "\t"
								+ tran.getTranAmount() + "\t"
								+ tran.getAccountId() + "\t"
								+ tran.getPayeeAccountId() + "\t"
								+ tran.getBalance() + "\n");
					}
					objOut.close();
				}

				myLogger.info("Transaction Record fetched");
				connection.commit();

			}
		} catch (SQLException e) {
			myLogger.error("ERRROR : while getting all Transaction records..... "
					+ e);
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} finally {

			if (st != null)
				try {
					st.close();
				} catch (SQLException e) {
					myLogger.error("ERRROR : while closing the statement "
							+ "Statement already closed..... " + e);
				}
		}
		return transactionDetails;

	}

	@Override
	public List<Transactions> showAllTransactions(LocalDate from, LocalDate to,
			int accountId) throws BankException {

		List<Transactions> transList = null;
		Transactions transaction = null;

		Date fromDate = Date.valueOf(from);
		Date toDate = Date.valueOf(to);

		String sql = "select * from transactions where dateoftransaction between to_date('"
				+ fromDate
				+ "','YYYY-MM-DD') and to_date('"
				+ toDate
				+ "','YYYY-MM-DD') and account_id=" + accountId;

		try {
			st = connection.prepareStatement(sql);

			rs = st.executeQuery(sql);

			transList = new ArrayList<Transactions>();

			while (rs.next()) {

				transaction = new Transactions();// creating cust obj

				transaction.setTransactionId(rs.getInt("transaction_id"));
				transaction
						.setTranDescription(rs.getString("tran_description"));
				transaction.setDateOfTransaction(rs
						.getDate("dateoftransaction").toLocalDate());
				transaction.setTransactionType(rs.getString("transactiontype"));
				transaction.setTranAmount(rs.getInt("tranamount"));
				transaction.setAccountId(rs.getInt("account_id"));
				transaction.setPayeeAccountId(rs.getInt("payee_account_id"));
				transaction.setBalance(rs.getInt("balance"));
				transList.add(transaction);

				String pathname = "src/DetailedStatement " + accountId + " "
						+ LocalDate.now() + ".txt";
				File file = new File(pathname);

				if (!file.exists()) {
					file.createNewFile();
				} else {
					Iterator<Transactions> iterator = transList.iterator();
					FileOutputStream out = new FileOutputStream(file);
					ObjectOutputStream objOut = new ObjectOutputStream(out);

					while (iterator.hasNext()) {
						Transactions tran = iterator.next();
						objOut.writeObject(tran.getTransactionId() + "\t"
								+ tran.getTranDescription() + "\t"
								+ tran.getDateOfTransaction() + "\t"
								+ tran.getTransactionType() + "\t"
								+ tran.getTranAmount() + "\t"
								+ tran.getAccountId() + "\t"
								+ tran.getPayeeAccountId() + "\t"
								+ tran.getBalance() + "\n");
					}
					objOut.close();
				}

				myLogger.info("Transaction record fetched");
			}
		} catch (SQLException e) {
			myLogger.error("Sorry no CustomerBean records found!!"
					+ e.getMessage());
			throw new BankException(e.getMessage());
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} finally {
			try {
				if (st != null)
					st.close();
			} catch (SQLException e) {
				myLogger.error("Sorry no CustomerBean records found!!"
						+ e.getMessage());
				throw new BankException(e.getMessage());
			}
		}
		return transList;
	}

	@Override
	public boolean loginCheck(int accountId, String password)
			throws BankException {
		boolean flag = false;
		String status = null;
		int user = 0;
		String pass = null;
		String sql1 = "select lock_status from user_table where account_id="
				+ accountId;
		String sql2 = "update user_table set lock_status=? where account_id="
				+ accountId;
		String sql3 = "select account_id,login_password from user_table where account_id="
				+ accountId + "and login_password='" + password + "'";
		try {
			pst = connection.prepareStatement(sql1);
			rs = pst.executeQuery();

			if (rs.next()) {

				status = rs.getString("lock_status");
			} else {
				flag = false;
				return flag;
			}

			if (status.equalsIgnoreCase("open")) {
				pst = connection.prepareStatement(sql3);
				rs = pst.executeQuery();

				if (rs.next()) {
					user = rs.getInt("account_id");
					pass = rs.getString("login_password");
					if (user == accountId && pass.equals(password)) {
						flag = true;
					}
				}

				else {

					count++;

					if (count == 3) {
						pst = connection.prepareStatement(sql2);
						pst.setString(1, "lock");
						pst.executeUpdate();
						// flag = false;
					}
					flag = false;

				}
			} else {
				System.err.println("Your Account is Locked");
				System.exit(0);
			}
		} catch (SQLException e) {

			e.printStackTrace();
		}

		return flag;
	}

	@Override
	public int resetPassword(String password, int accountId)
			throws BankException {

		String sql = "Update user_table set login_password=? where account_id=?";
		int flag = 0;

		try {

			connection.setAutoCommit(true);
			pst = connection.prepareStatement(sql);
			pst.setString(1, password);
			pst.setInt(2, accountId);

			flag = pst.executeUpdate();

		} catch (SQLException e) {
			myLogger.error("Sorry Unable to add User record!!" + e.getMessage());
			try {
				connection.rollback();
			} catch (SQLException e1) {
				throw new BankException(e1.getMessage());
			}
			throw new BankException(e.getMessage());
		} finally {
			try {
				if (pst != null)
					pst.close();
			} catch (SQLException e) {
				myLogger.error("Sorry Unable to add User record!!"
						+ e.getMessage());
				throw new BankException(e.getMessage());
			}
		}
		return flag;
	}

	@Override
	public int forgotPassword(String password, int accountId,
			String secretQuestion) throws BankException {
		// User user =null;
		String sql1 = "select secret_Question from User_table where account_id="
				+ accountId;
		String secret = null;
		String sql = "Update User_table set login_password=? where account_id=? and secret_Question=?";

		int flag = 0;

		try {
			connection.setAutoCommit(true);
			st = connection.createStatement();

			rs = st.executeQuery(sql1);
			if (rs.next()) {
				secret = rs.getString(1);

			}
			if (secretQuestion.equals(secret)) {
				pst = connection.prepareStatement(sql);
				pst.setString(1, password);
				pst.setInt(2, accountId);
				pst.setString(3, secretQuestion);

				flag = pst.executeUpdate();
			}
		}

		catch (SQLException e) {
			myLogger.error("Sorry Unable to add User record!!" + e.getMessage());
			try {
				connection.rollback();
			} catch (SQLException e1) {
				throw new BankException(e1.getMessage());
			}
			throw new BankException(e.getMessage());
		} finally {
			try {
				if (pst != null)
					pst.close();
			} catch (SQLException e) {
				myLogger.error("Sorry Unable to add User record!!"
						+ e.getMessage());
				throw new BankException(e.getMessage());
			}
		}
		return flag;

	}

	@Override
	public List<Transactions> showReport(LocalDate from, LocalDate to)
			throws BankException {
		List<Transactions> transList = null;
		Transactions transaction = null;

		Date fromDate = Date.valueOf(from);
		Date toDate = Date.valueOf(to);

		String sql = "select * from transactions where dateoftransaction between to_date('"
				+ fromDate
				+ "','YYYY-MM-DD') and to_date('"
				+ toDate
				+ "','YYYY-MM-DD')";

		try {
			st = connection.prepareStatement(sql);

			rs = st.executeQuery(sql);

			transList = new ArrayList<Transactions>();// created arrayList
														// object
			while (rs.next()) {
				transaction = new Transactions();// creating cust obj
				transaction.setTransactionId(rs.getInt("transaction_id"));
				transaction
						.setTranDescription(rs.getString("tran_description"));
				transaction.setDateOfTransaction(rs
						.getDate("dateoftransaction").toLocalDate());
				transaction.setTransactionType(rs.getString("transactiontype"));
				transaction.setTranAmount(rs.getInt("tranamount"));
				transaction.setAccountId(rs.getInt("account_id"));
				transaction.setPayeeAccountId(rs.getInt("payee_account_id"));
				transaction.setBalance(rs.getInt("balance"));
				transList.add(transaction);

				String pathname = "src/Report " + from + " to  " + to + ".txt";
				File file = new File(pathname);
				if (!file.exists()) {
					file.createNewFile();
				} else {
					Iterator<Transactions> iterator = transList.iterator();
					FileOutputStream out = new FileOutputStream(file);
					ObjectOutputStream objOut = new ObjectOutputStream(out);

					while (iterator.hasNext()) {
						Transactions tran = iterator.next();
						objOut.writeObject(tran.getTransactionId() + "\t"
								+ tran.getTranDescription() + "\t"
								+ tran.getDateOfTransaction() + "\t"
								+ tran.getTransactionType() + "\t"
								+ tran.getTranAmount() + "\t"
								+ tran.getAccountId() + "\t"
								+ tran.getPayeeAccountId() + "\t"
								+ tran.getBalance() + "\n");
					}
					objOut.close();
				}

				myLogger.info("Transaction record fetched");
			}
		} catch (SQLException e) {
			myLogger.error("Sorry no CustomerBean records found!!"
					+ e.getMessage());
			throw new BankException(e.getMessage());
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} finally {
			try {
				if (st != null)
					st.close();
			} catch (SQLException e) {
				myLogger.error("Sorry no CustomerBean records found!!"
						+ e.getMessage());
				throw new BankException(e.getMessage());
			}
		}
		return transList;
	}

	@Override
	public int changeDetails(Customer customer) throws BankException {
		int result = 0;
		pst = null;
		String sql = "Update customer set address=?,email=? where account_id=?";

		try {
			pst = connection.prepareStatement(sql);
			pst.setString(1, customer.getAddress());
			pst.setString(2, customer.getEmail());
			pst.setInt(3, customer.getAccountId());
			result = pst.executeUpdate();
		} catch (SQLException e) {

			e.printStackTrace();
		}

		return result;
	}

	@Override
	public boolean adminLogin(String adminName, String adminPassword)
			throws BankException {

		if (adminName.equals("admin") && adminName.equals("admin")) {

			return true;
		} else {
			return false;
		}
	}

	public int returnBalance(int accountId) {
		int balance = 0;
		String sql = "select account_balance from account_master where account_id="
				+ accountId;

		try {
			st = connection.createStatement();
			rs = st.executeQuery(sql);

			if (rs.next()) {
				balance = rs.getInt("account_balance");
			}
		} catch (SQLException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}

		return balance;
	}
}
